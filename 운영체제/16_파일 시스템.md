# 들어가며

- 파일시스템은 파일과 디렉터리를 보조 기억 장치에 일목요연하게 저장하고, 접근할 수 있게 하는 운영체제의 내부 프로그램

</br>

## 이번 시간 할 학습</br>

→ 파일과 디렉터리를 <u>**파일 시스템이 어떻게 보조 기억 장치에 할당하고 접근**</u>할 수 있을지에 대한 이론적인 내용을 학습하고,</br>

이런 이론을 기반해서 만들어진 **대표적인 파일 시스템** **<u>FAT 파일 시스템</u>** / **<u>Unix 파일 시스템</u>**을 학습

</br></br></br>



# 파티셔닝과 포매팅

파티셔닝과 포매팅을 해야지 파일 시스템을 통해서 파일과 티렉터리에 접근할 수 있음 (파일 시스템을 이용할 수 있다)

</br></br>

만약, 막 공장에서 만들어져서 한 번도 사용한 적 없는 새 하드디스크 or SSD가 있다고 가정</br>

그러면, 곧바로 파일을 생성하거나 저장할 수는 없음. </br>

→ `파티셔닝`과 `포매팅`을 해야 함</br>

</br>

</br>

## 파티셔닝

저장 장치의 논리적인 영역을 구획하는 작업</br>

*ex) 서랍 안에 마구잡이로 물건들을 넣어놓지 않고, 칸막이를 설치해서 목적에 따라 여러 물건들을 정돈해둠.*</br></br>



이런 식으로,</br>

칸막이처럼 **보조기억장치의 영역을 나누는 작업** == `파티셔닝`</br>

나뉘어진 **구획** 하나하나 == `파티션`</br>

</br></br></br>



## 포매팅

파일 시스템을 설정해서 어떤 방식으로 파일을 저장하고, 관리할지를 결정하고</br>

새로운 데이터를 쓸 준비를 하는 작업</br></br>

→ 파일 시스템은 포매팅할 때 결정된다</br>



- 파일 시스템의 종류는 다양하고
- 파티션마다 다른 파일 시스템을 설정할 수도 있음

</br>

#### 포매팅까지 완료해서 파일 시스템을 설정했다면, 이제부터 파일과 디렉터리 생성을 할 수 있다.

</br></br></br>



# 파일 할당 방법

- 포매팅까지 끝난 하드 디스크는 파일/디렉터리를 저장할 수 있음
- 운영체제는 파일/디렉터리를 ***블록 단위***로 읽고 씀

> 컴구에서 **하드디스크의 저장 단위**는 <u>섹터</u>임.</br>
>
> 근데 섹터는 너무 개수가 많고 크기도 작아서, 파일 시스템이 **모든 섹터를 관리하기 어려움**.</br></br>
>
>  
>
> 그래서 운영체제는 **하나 이상의 섹터**를 ***블록***이라는 단위로 묶은 뒤에 그걸로 파일/디렉터리를 관리함.

- 즉, 하나의 파일이 보조기억장치에 저장될 때에는 여러 개의 블록에 걸쳐서 저장된다.

그리고,</br>

 파일의 크기가 작다면 적은 수의 블록에 걸쳐서 저장될 것이고,</br>

만약 파일의 크기가 크다면 여러 개의 블록에 걸쳐서 저장될 것임.</br></br>



여러 개의 블록에 걸쳐서 파일을 할당하는 방법 중에서 크게 2가지의 방법이 있음.</br>

→ `연속 할당`, `불연속 할당`*(연결 할당, 색인 할당)*</br>

</br></br></br>



# 연속 할당

이름 그대로, 보조기억장치의 연속적인 블록에 걸쳐서 파일을 저장하는 방식</br>

</br>

- **연속된 파일에 접근**하기 위해 <u>필요한 정보</u>
  - **첫 번째 블록 주소, 블록 단위의 길이**

</br>

- **디렉터리 엔트리** : 파일 이름 & **<u>첫 번째 블록 주소</u>** & **<u>블록 단위 길이 명시</u>**가 들어감

</br></br>

**But,**</br>

현대에 가장 많이 사용되는 방식은 불연속 할당</br>

→ 부작용 때문!</br>

</br>

## 연속 할당의 부작용

구현이 단순하지만 `외부 단편화`를 야기할 수 있다!</br>

→ 파일이 연속적으로 저장되어 있다가, 중간중간에 있는 파일들이 없어지면 총 빈 공간이 충분히 커도, 사이사이 블록들에 파일들을 넣어야 해서 큰 파일은 넣지 못함</br>

</br></br></br>



# 불연속 할당 - 연결 할당

- 각 블록의 일부에 다음 블록의 주소를 적어놔서, **<u>각 블록이 다음 블록을 가리키는 형태</u>**로 할당
- 그래서 여기저기 블록들에 흩어져서 저장되어도 됨

</br></br>

## 연결 할당의 디렉터리 엔트리

파일 이름 & **<u>첫 번째 블록 주소</u> & <u>블록 단위의 길이</u>**

</br></br></br>



## 연결 할당의 단점

- 반드시 첫 번째 블록부터 하나씩 읽어들여야 한다
- 오류 발생시 해당 블록 이후 블록은 접근이 어렵다

→ 이런 점들을 보완하기 위해 FAT 파일 시스템을 사용함

</br></br></br>



# 불연속 할당 - 색인 할당

- 파일의 모든 블록 주소를 **<u>색인 블록이라는 하나의 블록에 모아 관리</u>**하는 방식

</br></br>

## 색인 할당의 디렉터리 엔트리

파일 이름 & **<u>색인 블록 주소</u>**</br>

</br></br></br>



# FAT 파일 시스템

**File Allocation Table**

- 연결 할당 기반 파일 시스템
- 연결 할당의 단점을 보완

</br>

### 연결 할당에서 단점이 발생했던 근본적인 이유</br>

= <u>모든 블록 안에 **다음 번지 블록의 주소를 기록**했기 때문</u>에 발생했음</br>

*(블록마다 다음 블록의 주소를 적어놨는데 **그중 하나라도 블록이 고장나면** 블록을 제대로 읽어들일 수가 없음)*</br>

</br>

### 그런데 다음 블록의 주소를 다 모아서 테이블 형태로 관리하면 해결됨

= `FAT 파일 시스템`</br>

</br></br></br>

**FAT 파일 시스템**을 이용하면 **<u>파티션</u>**은 다음과 같이 **<u>구성</u>**됨

- 예약 영역
- FAT 영역
- 루트 디렉터리 영역
- 데이터 영역

</br></br>

## FAT 파일 시스템의 디렉터리 엔트리

파일의 속성까지도 디렉터리 엔트리에 표기하는 파일 시스템이 FAT 파일 시스템

- 확장자
- 속성 (읽기 전용 / 숨긴 파일 / 시스템 파일 등의 정보)
- 마지막 접근 시간
- 마지막 수정 시간
- 시작 블록
- 파일 크기

등..</br>

</br></br>



# 유닉스 파일 시스템

- 색인 할당 기반 파일 시스템

- 색인 블록 == i-node

  > i-node는 파일의 속성 정부 & 15개의 블록 주소를 저장할 수 있음



**유닉스 파일 시스템**에서는 <u>**파일마다 i-node**</u>를 갖고 있고,</br>

`i-node`를 보면 <u>*어떤 파일이, 어떤 속성을 갖고 있고, 어디에 저장되어 있는지*</u> 전부 알 수 있음</br>

= **유닉스 파일 시스템의 중추**</br>

</br>

i-node는 유닉스 파일 시스템에서 파티션 내의 특정 영역에 모여서 저장되어 있음</br>

= `i-node 영역`</br>

</br></br>



그런데, i-node는 15개까지 블록 주소를 저장할 수 있지만 **15개 블록보다 큰 파일**은?</br></br>

## 유닉스 파일 시스템이 큰 파일을 저장하는 방법

1. 블록 주소 중에서 <u>**12개까지**</u>는 ***직접 블록 주소***를 저장함 (일반적으로 그냥 저장)

   > **직접 블록** : <u>파일 데이터</u>가 저장된 블록

</br></br>

2. 1번으로 충분하지 않다면 <u>**13번째 주소**</u>에 ***단일 간접 블록 주소***를 저장

   > **단일 간접 블록** : <u>파일 데이터를 저장한 블록 주소</u>가 저장된 블록

→ **데이터의 주소를 저장한 블록**의 <u>주소를 저장</u>한다는 뜻

</br></br>

3. 2번으로 충분하지 않다면 <u>**14번째 주소**</u>에 ***이중 간접 블록 주소*** 저장

   > **이중 간접 블록** : <u>단일 간접 블록들의 주소들</u>을 저장하는 블록

</br></br>

4. 3번으로 충분하지 않다면 <u>**15번째 주소**</u>에 ***삼중 간접 블록 주소*** 저장

   > **삼중 간접 블록** : <u>이중 간접 블록들의 주소</u>를 저장하는 블록

</br></br></br>



## 유닉스 파일 시스템의 디렉터리 엔트리

- **i-node 번호** & 파일 이름

