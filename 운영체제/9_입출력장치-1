- 프로그램 입출력
  - 메모리맵 출력
  - 고립형 입출력
- 인터럽트 기반 입출력
- DMA 입출력
  </br>
  `메모리맵 출력` : 메모리에 접근하기 위한 주소 공간과 입출력 장치에 접근하기 위한 주소 공간을 하나의 주소 공간으로 간주하는 방법
  </br>

> EX) 1024개의 주소를 표현할 수 있으면,</br>
> 0 ~ 511 : 매모리를 위한 주소 공간</br>
> 512 ~ 1023 : 입출력장치를 위한 주소 공간

> - 메모리와 입출력장치는 같은 주소 공간 사용
> - 메모리 주소 공간이 축소됨
> - 메모리와 입출력장치에 같은 명령어 사용 가능  

  

​    

`고립형 입출력` : (입출력 읽기/쓰기 선을 활성화시키는 입출력 전용 명령어 사용)  

> EX)
>
> 메모리를 위한 주소 공간에 접근하고 싶다면 -> 메모리 읽기/쓰기 선을 활성화  
>
> 입출력장치를 위한 주소 공간에 접근하고 싶다면 -> 입출력장치 읽기/쓰기 선을 활성화시키는 입출력 전용 명령어를 사용

> - 메모리와 입출력장치는 분리된 주소 공간 사용
> - 메모리 주소 공간이 축소되지 않음
> - 입출력 전용 명령어 사용

  

> ### 인터럽트 복습 ###
>
> `(하드웨어) 인터럽트` : CPU 사이클의 낭비를 막기 위해서, 입출력장치가 일하는 동안 다른 일을 할 수 있게 하기 위한 일종의 알람
>
> `플래그 레지스터 속 인터럽트 비트` : 인터럽트 비트가 활성화되면 인터럽트를 받아들일 수 있고, 비활성화되면 (하드웨어)인터럽트를 받지 않음.
>
> `인터럽트 요청 신호` : 끼어들어도 되는지 입출력장치가 CPU에게 보내는 요청 신호
>
> `인터럽트 서비스 루틴` : 인터럽트를 처리하기 위한 특별한 프로그램

–> 사실 하드웨어 인터럽트는 이 ***장치 컨트롤러***에 의해서 발생함.  



# 인터럽트 방식 #

CPU가 장치컨트롤러에 입출력 명령을 보내고 장치 컨트롤러는 일을 다 끝내면,  

장치 컨트롤러가 CPU한테 인터럽트 요청 신호를 보냄



​	—> 이런 ***인터럽트 방식은 프로그램 방식보다 CPU 사이클을 아낄 수 있음.***  

왜냐하면, **프로그램 방식**은 *CPU가 상태 레지스터를 주기적으로 읽어보면서* 하드 디스크의 준비 여부를 확인했지만 (콜링) </br>

**인터럽트 방식**은 *장치컨트롤러가 인터럽트 요청 신호를 보내면 그 때 가서 봐주면 됨.*  

  

# 동시다발적인 인터럽트 #

만약, 여러 입출력장치들이(키보드, 모니터, 스피커 등등) 동시에 CPU에게 인터럽트 요청을 보낸다면 CPU는 어떻게 처리해야 할까?  

## - 인터럽트 발생 순서대로? ##

-> 가능함. CPU가 만약 플래그 레지스터 속 **인터럽트 비트를 비활성화** 하고 인터럽트를 처리하는 경우는 **다른 인터럽트를 받아들이지 않겠다!**라는 것과 같음. 그래서 그렇게 비활성화하는 방식을 써서 순차적으로 처리할 수는 있음.  

-> **하드웨어 인터럽트는 인터럽트 비트 비활성화 방식**으로 할 수 있는데, ***NMI 인터럽트***의 경우에는 인터럽트 비트 비활성화해서 **순차적으로 처리가 불가능**함. (하드웨어가 고장났거나, 정전이 발생했다던지 중요도가 높아서 빨리 처리해야 하는 인터럽트들)  

> 현실적으로 모든 인터럽트를 순차적으로 처리할 수는 없음.
>
> 인터럽트 중에서도 **더 빨리 처리해야 하는 인터럽트**(***우선순위가 높은 인터럽트***)가 있기 때문.
>
> ​	-> 그런 상황에서는 **덜 중요한 인터럽트 A**를 실행하는 도중에 **더 중요한 인터럽트 B**로 ***점프***해서 인터럽트를 먼저 수행
>
> ​	(1. NMI가 발생했거나, 2. 플래그 레지스터 속 인터럽트 비트를 활성화한 채 인터럽트를 처리하는 경우)

### PIC를 사용

`PIC` (Programmable Interrupt Controller)

1.  여러 장치 컨트롤러에 연결되어
2. 장치 컨트롤러의 **하드웨어 인터럽트**의 우선순위를 파악한 뒤 (*NMI의 우선순위까지 판단하지는 않음*)
3. CPU에게 지금 처리해야 하는 인터럽트가  무엇인지 판단하는 하드웨어

  

  

# 프로그램 입출력, 인터럽트 기반 입출력의 공통점?

### => 입출력장치와 메모리 간의 데이터 이동은 <u>***CPU가 주도***</u>하고, 이동하는 데이터도 <u>반드시 *CPU를 거친다*</u>.

1. 만약 **입출력장치의 데이터**를 메모리에 저장하는 경우  

장치컨트롤러 -> CPU의 레지스터로 데이터 읽음 -> 메모리에 씀  

  

2. 만약 **메모리의 데이터**를 입출력장치에 저장하는 경우

메모리 -> CPU의 레지스터로 데이터 읽음 -> 장치컨트롤러에 씀

  

  



### 그런데, 가뜩이나 바쁜 CPU.. 매번 입출력장치의 모든 데이터를 다루면 힘들텐데?  

그래서 나온 것이

# DMA 입출력

> CPU를 거치지 않고 **입출력 장치**가 **메모리에 직접적으로 접근**하는 기능
>
> (**DMA 컨트롤러**라는 하드웨어를 이용)



## DMA 입출력 과정

1. CPU가 입출력작업을 해야 할 때 DMA 컨트롤러에 입출력 작업을 명령
2. DMA 컨트롤러는 **CPU 대신 장치 컨트롤러와 상호작용**하며 입출력 작업을 수행 (필요할 경우 DMA 컨트롤러는 메모리에 직접적으로 접근함)
3. 입출력 작업이 끝나면 DMA 컨트롤러는 인터럽트를 통해 CPU에 작업이 끝났음을 알림.

=> CPU는 입출력작업에 개입 안해도 되니까 그 시간에 다른 일을 더 할 수 있는 거임.



그런데 메모리도 시스템버스에 연결되어 있고, 장치 컨트롤러도 시스템버스에 연결되어 있다면

그러면 DMA 컨트롤러는 메모리를 읽기 위해서 시스템버스를 통해 갈 수밖에 없음.

***그런데*** 시스템 버스는 <u>공용 자원이라서 동시 사용이 안됨.</u>  

  

즉,  

CPU가 시스템 버스를 사용할 때 DMA 컨트롤러는 시스템 버스를 사용할 수 없고,  

DMA 컨트롤러가 시스템 버스를 사용할 때는 CPU가 시스템 버스를 사용할 수 없음.

​	=> 그래서 DMA 컨트롤러는

 	1. CPU가 시스템 버스를 이용하지 않을 때마다 조금씩 시스템 버스를 이용
 	2. CPU가 일시적으로 시스템 버스를 이용하지 않도록 허락을 구하고 시스템 버스 이용

==> 이런 걸, Cycle stealing이라고 부름

  

  # 입출력버스

## 장치컨트롤러가 직접적으로 시스템 버스에 연결되어 있으면 안됨.

 왜냐하면 DMA 컨트롤러의 중개 과정에서 2번씩 시스템버스를 점유하게 되기 때문임.  

그래서 **입출력장치(&장치컨트롤러)들은 입출력 버스**에 연결되어 있고, </br>
**CPU, DMA 컨트롤러, 메모리는 시스템 버스에 연결**되어 있어서</br>
<u>DMA 컨트롤러</u>가 <u>장치들에 메모리를</u> 갖다줘야 한다면 <u>시스템 버스를 이용</u>해서 한 번만 cycle stealing을 하고
</br>***입출력버스로 갈아타서*** <u>입출력장치들한테 줌</u>
