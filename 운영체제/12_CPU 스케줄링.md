# CPU 스케줄링

운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것</br>

만약, 분배가 제대로 안되면 꼭 실행되어야 하는 프로세스가 실행이 안되거나, 짜바리 프로세스들만 계속 실행되게 됨.</br>

## 프로세스 우선순위

- 가장 공정한 CPU 스케줄링?

>  프로세스의 우선순위에 맞게 CPU 스케줄링이 이루어지는데, 그 우선순위는 사용자가 정할 수도 있고 운영체제가 내부적으로 정한 우선순위도 있음.

→ 입출력 작업이 많은 프로세스(=`입출력 집중 프로세스`)의 우선순위는 CPU 작업이 많은 프로세스(=`CPU 집중 프로세스`)의 우선순위보다 높다!

> 입출력 집중 프로세스는 CPU 집중 프로세스에 비해 **당분간 대기상태에 더 길게 머무르게 될 거니까**(자주 사용하지 않으니까) 입출력 집중 프로세스부터 처리해주고 ***CPU 집중 프로세스이 이후 계속 집중해서 CPU를 사용할 수 있게 하는 것!***

***이런 우선순위는 운영체제가 부여하고***</br>

***PCB에 저장됨***</br></br>



그런데 운영체제가 PCB 하나하나 뒤적거리면서 우선순위를 찾아내는 건 비효율적임.</br>

그래서 사용하는 것이, `스케줄링 큐`</br>

# 스케줄링 큐

: 어떤 자원을 이용하고 싶어하는 프로세스들이 서는 줄 (자원 이용하고 싶으면 서는 줄)</br>

예를 들면, 'CPU를 쓰고 싶은 프로세스 큐', '하드디스크를 쓰고 싶은 프로세스 큐', '프린터를 쓰고 싶은 프로세스 큐' 등등 있음.

> 스케줄링에서의 큐는 **일반 큐**처럼 ***반드시 선입선출(FIFO) 방식일 필요는 없음!***

## 종류

- **준비 큐**

  : *CPU를 이용하려고 하는* 프로세스들이 서는 줄 (즉, CPU 쓰려고 준비 상태인 애들)

- **대기 큐**

  : *입출력장치를 이용하려고 하는* 프로세스들이 서는 줄 (즉, CPU 아직 안쓰는 애들)

> 먼저 **준비**했거나 **대기**했다고 해서, 먼저 CPU를 쓸 수 있는 건 아니고 우선순위가 높은 프로세스부터 CPU를 이용

## 과정

`준비 상태`의 **준비 큐** → `디스패치`되어서 `실행 상태`가 됨 </br>

→ 실행 시간이 완료되면 `타이머 인터럽트`가 발생 → 다시 준비 큐에서 **우선순위 높은 프로세스**를 뽑아서 `디스패치`함 </br>

→ 실행하다가 만약 입출력장치를 써야 한다면(입출력 중심 프로세스였을 수도) 입출력장치 요청을 해서 대기 큐에 들어가 `대기 상태`가 됨 </br>

→ 입출력이 끝났으면 `입출력 완료 인터럽트`를 보내서 **다시 준비 큐**에 들어감

</br>

## 대기 큐

보통 대기 큐는 입출력장치별로 하나씩 있음. 그래서 같은 장치를 요구한 프로세스들은 같은 큐에서 대기함.

</br>

# 선점형 스케줄링 & 비선점형 스케줄링

만약 **프로세스 A**가 CPU를 쓰고 있는데, **프로세스 B**가 와서는 '급한데 CPU 먼저 써도 될까요?'라고 하면 어떡할까?</br>

1. **프로세스 A**로부터 CPU를 빼앗아서 **프로세스 B**에게 준다.
2. **프로세스 A**의 작업이 끝날 때까지 기다린다.

</br>

이것들이 각각 `선점형 스케줄링`, `비선점형 스케줄링`이다.

## 선점형 스케줄링

: 다른 프로세스가 CPU를 쓰고 있어도 더 급한 프로세스가 빼앗아서 CPU를 쓸 수 있게 하는 스케줄링</br>

- 장점 : 어느 한 프로세스의 자원 독점을 막고, 프로세스들에 자원을 골고루 배분할 수 있다.

- 단점 : 그만큼 문맥 교환 과정에서 오버헤드가 발생할 수 있다.

  </br>

## 비선점형 스케줄링

: 다른 프로세스가 CPU를 쓰고 있으면 기다려야 하는 스케줄링

- 장점 : 선점형 스케줄링에 비해 문맥 교환에서 발생하는 오버헤드가 적다.
- 단점 : 모든 프로세스가 골고루 자원을 이용하기 어렵다.
