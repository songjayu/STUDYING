# 프로세스

- `포그라운드 프로세스`: 사용자가 볼 수 있는 공간에서 실행되는 프로세스
- `백그라운드 프로세스` : 사용자가 볼 수 없는 공간에서 실행되는 프로세스
  - 사용자와 직접 상호작용 가능한 백그라운드 프로세스
  - 데몬(daemon), 서비스(service) : 사용자와 상호작용 x, 그저 정해진 일만 수행하는 프로세스

</br>

# 프로세스 제어 블록

모든 프로세스는 실행을 위해 CPU가 필요하다. </br>

But, <u>CPU 자원은 한정</u>되어 있다.</br>

- **프로세스들은 돌아가며 한정된 시간 만큼만 CPU 이용**
  - 자신의 차례에 정해진 시간만큼 CPU 이용 (차례가 끝나면 다음 프로세스에게 CPU 이용권을 줌)
  - `타이머 인터럽트`*(차례 끝났다고 알려줌)*가 발생하면 차례 양보

- 빠르게 번갈아 수행되는 프로세스들을 관리해야 함

- 이를 위해 사용하는 **자료 구조**가 ***프로세스 제어 블록*** (이하 **PCB**)

  - **프로세스 관련한 여러 정보**를 저장하는 자료 구조

    - *프로세스 ID, 레지스터 값, 프로세스 상태, CPU 스케줄링 정보, 메모리 정보, 사용한 파일과 입출력장치 정보 등*

    - > 1. 프로세스 ID (=PID) : 특정 프로세스를 식별하기 위해 부여하는 고유 번호 (학번 같은 거)</br>
      ></br>
      > 2. 레지스터 값 : (레지스터 값이 왜 PCB에 담겨있는지 파악하는 것이 중요) 프로세스는 다시 자기가 실행할 차례가 오면 예전에 자기가 사용한 레지스터 값을 알고 있어야 실행을 재개할 수 있으니까 레지스터 값이 PCB에 있어야 함!</br></br>
      > 3. 프로세스 상태 : 입출력장치를 사용하기 위해 기다리는 상태, CPU를 사용하기 위해 기다리는 상태, CPU를 이용 중인 상태, …</br></br>
      > 4. CPU 스케줄링 정보 : 프로세스가 언제, 어떤 순서로 CPU를 할당받을지에 대한 정보</br></br>
      > 5. 메모리 정보 : 프로세스가 어느 주소에 저장되어 있는지에 대한 정보
      >    - 페이지 테이블 정보 (지금으로서는 '메모리 주소를 알 수 있는 정보가 담기는구나' 정도로')</br></br>
      > 6. 사용한 파일과 입출력장치 정보 : 어떤 입출력장치가 이 프로세스에 할당되었는지, 어떤 파일을 열었는지 PCB에 기록

  - 마치 **상품에 달린 태그**와 같은 정보
  - 프로세스 생성 시 **커널 영역에 생성**해서, 종료하면 폐기함

</br></br></br>

# 문맥 교환 (Context Switch)

### 한 프로세스(e.g 프로세스 A)에서 다른 프로세스(e.g 프로세스 B)로 **실행 순서**가 넘어가면 어떤 과정이 생길까?

1. 기존에 실행되던 프로세스 A는 지금까지의 **중간정보**를 **백업**해야 함

 - 프로그램 카운터 등 각종 레지스터 값, 메모리 정보, 열었던 파일, 사용한 입출력장치 등
 - 이런 중간 정보 == 문맥 (context)
 - ***다음 자기 차례가 왔을 때 실행을 재개하기 위한 정보***
 - <u>실행 문맥을 백업</u>해두면 <u>언제든 해당 프로세스의 실행을 재개</u>할 수 있다!

2. 이후 실행할 **프로세스 B의 문맥**을 **복구**

### <u>기존 프로세스를 PCB에 백업</u> -> <u>이후 실행할 프로세스를 PCB로부터 복구</u> 과정을 거치면서 자동으로 실행되는 프로세스가 전환됨.

</br>

## 커널 영역에서는 프로세스의 PCB가 저장되었다면, 사용자 영역에서는?

### 사용자 영역에서는 특정 영역을 나누어서 저장됨. 여러 영역이 있지만 <u>대표적으로 4개의 영역</u>이 있음.

- **코드**(=**텍스트**) 영역

- **데이터** 영역

- **힙** 영역

- **스택** 영역

</br></br>

# 코드 영역

코드와 기계어로 이루어진 명령어가 저장됨.</br>

즉, 데이터가 아니라 **CPU가 실행할 명령어가 저장되는 공간**임. 근데 이 명령어 자체가 바뀔 일은 없어서 쓰기가 금지된 영역임. (read-only)

</br>

# 데이터 영역

잠깐 썼다가 없앨 데이터가 아니라, 프로그램 실행하는 동안 계속 쓸 데이터를 저장함

- e.g. 전역 변수

</br>

### 코드 영역, 데이터 영역은 크기가 고정되어 있음. (명령어 자체가 바뀔 일이 없고, 데이터는 쭉 유지할 거니까) ##

</br>-> `코드 영역`, `데이터 영역` : 정적 할당 영역</br>

# 힙 영역

프로그램을 만드는 사용자, 즉 프로그래머가 직접 할당할 수 있는 저장 공간

</br>

만약 프로그래밍을 하다가 힙 영역에 메모리를 할당했다면, 언젠가는 힙 영역에 할당한 ***메모리 공간을 반환***해야 함!</br>

요즘은 **프로그래밍 언어가 알아서 반환**해주는 경우가 있는데, 이걸 ***가비지 컬렉션***(Garbage Collection)이라고 함.

</br>

C언어 같은 옛날 프로그래밍 언어는 가비지 컬렉션 기능이 없어서, 일일이 메모리를 반환해줘야 한다.</br>

그렇지 않으면, 할당된 힙 영역의 메모리는 <u>하는 일도 없는데 메모리 공간만 차지</u>하는 *** 메모리 누수(Memory Leak) ***가 발생!

</br>

# 스택 영역

데이터가 일시적으로 저장되는 공간 (데이터 영역에 담기는 값들과 다르게 잠깐 쓰다가 말 데이터들이 저장됨)

- e.g. 매개 변수, 지역 변수

</br>

### 힙 영역, 스택 영역은 값을 계속 바꿀 수 있음.  ##

</br>-> `힙 영역`, `스택 영역` : 동적 할당 영역</br>

- **힙 영역** : 낮은 주소 -> 높은 주소로 할당
- **스택 영역** : 높은 주소 -> 낮은 주소로 할당

-> 크기가 계속 변하니까 서로 반대되는 방향으로 차오르게 해서 주소가 겹치지 않게 함.
