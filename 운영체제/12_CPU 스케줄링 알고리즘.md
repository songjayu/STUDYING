# CPU 스케줄링 알고리즘

프로세스들을 스케줄링하는 **실질적인 방법들 7가지**

> 중요햔 것은 스케줄링 알고리즘의 작동 방식, 장단점과 같은 아이디어! 정확한 이름을 외우는 것은 큰 의미 없음

1. 선입 선처리 스케줄링
2. 최단 작업 우선 스케줄링
3. 라운드 로빈 스케줄링
4. 최소 잔여 시간 우선 스케줄링
5. 우선순위 스케줄링
6. 다단계 큐 스케줄링
7. 다단계 피드백 큐 스케줄링

</br>

# 선입 선처리 스케줄링

**FCFS (First Come First Served) 스케줄링**

- 단순히 `준비 큐`에 ***삽입된 순서대로 처리***하는 `비선점 스케줄링`
- 먼저 CPU를 요청한 프로세스부터 CPU 할당

**공정해보일 수 있지만 큰 부작용이 있음**</br>

- **단점** : 프로세스들이 CPU를 할당받기 위해서 <u>기다리는 시간이 매우 길어질 수 있음</u> **(호위효과)**

→ 즉, 선입 선처리 스케줄링은 ***호위효과라고 하는 부작용***을 야기할 수 있는 스케줄링 방식!

</br></br>

그럼, 호위효과를 막으려면 어떡해야 할까?</br>

→ 단순히 생각해보면 그냥 CPU 사용시간이 긴 프로세스를 나중에 실행하고 CPU 사용시간이 짧은 프로세스를 먼저 실행하면?

</br>

# 최단 작업 우선 스케줄링

**SJF (Shortest Job First) 스케줄링**

- *호위효과를 막을 수 있음*
- CPU 사용이 긴 프로세스는 나중에 실행, <u>CPU 사용 시간이 짧은 프로세스</u>를 먼저 실행
- 즉, ***CPU 사용 시간이 가장 짧은 프로세스부터 처리하는 스케줄링 방식***

> 선점형 스케줄링, 비선점형 스케줄링 둘 다로 구현될 수 있음. (기본적으로는 비선점형 스케줄링으로 분류)

</br>

# 라운드 로빈 스케줄링

**RR (Round Robin) 스케줄링**

- 선입 선처리 스케줄링 + <u>타임 슬라이스</u>(time slice)
- ***정해진 <u>타임 슬라이스만큼의 시간 동안</u> <u>돌아가며 CPU를 이용</u>***하는 ***<u>선점형 스케줄링</u> 방식***

> **용어 알아두기**
>
> - 라운드 로빈 (RR) : 쭉 차례대로 돌아가면서 무언가를 한다
> - 타임 슬라이스 : 각 프로세스가 CPU를 사용하는 것에 정해진 시간

일단 **큐에** **삽입된 순서대로** 프로세스를 처리하되, **정해진 시간만큼**만 CPU를 쓰게 함.</br>

만약 **정해진 시간을 모두 썼는데**도 프로세스가 완료되지 않았다면 ***다시 큐의 맨 뒤에 삽입*** (**문맥교환**)

- 따라서 ***타임 슬라이스의 크기***가 중요해짐
  - 타임 슬라이스가 너무 크면, 선입 선처리 스케줄링이랑 똑같은 효과로 `호위 효과`가 생길 수 있음
  - 타임 슬라이스가 너무 작으면, 문맥 교환에 발생하는 오버헤드 때문에 CPU의 부담이 너무 커짐

</br>

# 최소 잔여 시간 우선 스케줄링

**SRT (Shortest Remaining Time) 스케줄링**

- `최단 작업 우선 스케줄링` + `라운드 로빈 스케줄링`

- ***최단 작업 우선 스케줄링*** : **작업 시간이 짧은 프로세스부터** 처리하는 스케줄링 알고리즘
- ***라운드 로빈 스케줄링*** : 정해진 **타임 슬라이스만큼** 돌아가며 사용하는 스케줄링 알고리즘

</br>

즉, <u>정해진 시간만큼 CPU를 이용</u>하되, ***남은 작업 시간이 가장 적은 프로세스를 선택하는 스케줄링 방식***

</br>

# 우선순위 스케줄링

- 프로세스들에게 우선순위를 부여하고, 우선순위가 높은 프로세스부터 실행하는 스케줄링 알고리즘
- <u>우선순위가 같은 프로세스</u>들은 **선입 선처리**로 스케줄링
- 최단 작업 우선 스케줄링, 최소 잔여 시간 스케줄링 ⊂ 우선순위 스케줄링
  - ***최단 작업*** = <u>작업 시간</u>이 짧은 프로세스에게 **높은 우선순위**를 부여
  - ***최소 잔여 시간*** = <u>남아있는 시간</u>이 짧은 프로세스에게 **높은 우선순위**를 부여

</br>

## 우선순위 스케줄링의 문제점

- 근본적인 문제점 = 기아(Starvation) 현상
- <u>우선순위 높은</u> 프로세스만 주구장창 실행
- <u>우선순위 낮은</u> 프로세스는 (준비 큐에 먼저 삽입되었음에도 불구하고) **실행 연기**

</br>

## 기아 현상 해결 방법

### 에이징 (Aging)

- 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식 (오래 둘수록 우선순위 높아짐)
- 대기 중인 프로세스의 우선순위를 마치 나이 먹듯 점차 증가시키는 방법
- 즉, 우선순위가 낮아도 언젠가는 우선순위가 높아진다

</br>

# 다단계 큐 스케줄링

**멀티레벨 큐 스케줄링**

- **우선순위 스케줄링**의 <u>발전된 형태</u>
- 우선순위별로 *** 준비 큐를 여러 개*** 사용하는 스케줄링 방식
- 우선순위 0 큐, 우선순위 1 큐, 우선순위 2 큐
  - 가령 어떤 큐에는 우선순위가 비교적 높아야 되는 입출력 집중 프로세스가 삽입될 수 있음
  - 어떤 큐에는 타임 슬라이스를 적게, 크게 지정할 수도 있음
  - 어떤 큐에는 선입선 처리 방식, 라운드로빈 등으로 스케줄링

</br>

그러니까 큐 별로 스케줄링을 달리 적용해서 프로세스를 유형별로 처리하는 게 되게 쉬워짐

</br>

## 다단계 큐 스케줄링의 문제점

**다단계 큐 스케줄링**에서는 프로세스가 큐 간에 이동할 수 없음</br>

우선순위가 낮은 프로세스는 계속해서 우선순위가 낮은 큐에 머무를 수밖에 없음</br>

→ ***기아 현상***이 발생할 수 있음</br>

</br>

## 다단계 큐 스케줄링 기아 현상의 해결 방법

→ 다단계 피드백 큐 스케줄링

</br>

# 다단계 피드백 큐 스케줄링

**Multilevel feedback queue 스케줄링**

- 다단계 큐 스케줄링의 발전된 형태
- 큐 간의 이동이 가능한 다단계 큐 스케줄링

> 다단계 큐 스케줄링에서는 기본적으로 <u>큐 간의 이동이 불가</u>하기에,</br>
>
> ***우선순위가 낮은 프로세스***는 계속해서 **실행 연기**가 우려되고, **기아 현상**이 발생할 수 있음.

- 어떤 프로세스의 **CPU 시간이 길면** <u>우선순위가 낮아지고</u> 어떤 프로세스의 **낮은 우선순위 큐에서 너무 오래 기다리면** <u>우선순위를 높이는 방식</u>

- CPU 스케줄링 방식의 **가장 일반적인 형태**
