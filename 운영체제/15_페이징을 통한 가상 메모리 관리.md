# 들어가며

## 연속 메모리 할당의 2가지 문제점

- 외부 단편화
- 물리 메모리보다 큰 프로세스 실행 불가

→ 이번 시간에는 이 문제들을 **가상 메모리 관리**, **<u>페이징</u>**을 통해 해결하는 방법을 배움</br>

> `페이징`은 **가상 메모리 관리 방법** 중 하나

</br></br>

`가상 메모리` : 실행하고자 하는 프로그램을 ***일부만 메모리에 적재***해서, <u>실제 물리 메모리보다</u> 큰 프로세스를 실행할 수 있게 하는 기술</br>

- **페이징**, 세그멘테이션

</br></br></br></br>



# 페이징

- ***외부 단편화가 발생했던 근본적인 문제?***

  → <u>각기 다른 크기의 프로세스</u>가 메모리에 연속적으로(프로세스가 안쪼개지고 통으로 적재) 할당되었기 때문</br>

  **(만약 메모리에 적재되는 프로세스가 전부 똑같은 크기를 갖고 있었다면 외부 단편화는 발생 X)**</br>

  </br></br>

- 프로세스를 일정 크기로 자르고, 이걸 메모리에 ***불연속적으로***(ABCBA 같은 순서도 가능) 할당할 수 있다면?

</br></br>

### 페이징

**paging**

- <u>***프로세스**의 논리 주소 공간*</u>을 ***페이지(page)***라는 **일정 단위**로 자르고
- <u>***메모리**의 물리 주소 공간*</u>을 ***프레임(frame)***이라는 페이지와 동일한 **일정한 단위**로 자른 뒤
- 페이지를 프레임에 할당하는 가상 메모리 관리 기법

</br></br>

## 페이징에서의 스와핑

- 프로세스 단위의 스왑 인, 스왑 아웃이 아니라, **페이지 단위**로 쪼갠 걸 **스왑 인**(**<u>페이지 인</u>**이라고 함), **스왑 아웃**(**<u>페이지 아웃</u>**이라고 함)
- 메모리에 적재될 필요가 없는 페이지들은 보조기억장치로 스왑 아웃

</br>

> 어떤 프로세스를 실행하기 위해서 모든 페이지가 전부 다 메모리에 꼭 저장되어 있을 필요는 없다는 것을 시사함!</br>

### 즉, 현재 프로세스에 필요한 모든 페이지들이 메모리 안에 있을 필요는 없고, 일부는 보조기억장치의 스왑 영역에 있어도 실행이 가능함!

→ <u>물리 메모리보다 큰 프로세스</u>도 실행될 수 있다

</br></br></br>

## 문제점

- 프로세스를 이루는 페이지가 어느 프레임에 적재되어 있는지 CPU가 일일이 알기가 어렵다.

  : 만약 프로세스 A가 쪼개져서 산발적으로 저장되어 있으면 그 쪼개진 페이지들이 어디 있는지 알기가 어려움

</br>

- 프로세스가 메모리에 불연속적으로(쪼개져서) 배치되어 있다면 CPU 입장에서는 이걸 순차적으로 실행할 수가 없음.

  : CPU 입장에서 '다음에 실행할 명령어 위치'를 찾기가 어려워짐 (A 나머지 어딨어)

 </br></br>

→ 이런 문제를 해결하기 위해서 사용하는 것이 ***페이지 테이블***

</br></br></br></br>



# 페이지 테이블

현재 <u>**어떤 프로세스의, 무슨 페이지가, 어느 프레임**</u>에 할당되어 있는지를 짝지어 주는 **이정표**</br>

→ 페이징을 이용하면, **반드시 페이지 테이블**을 이용함</br>

</br>

- 현재 프로세스가 (**실제 메모리 내의 주소**인) **<u>*물리 주소 내에서*</u>**는 실제로는 <u>불연속적</u>으로 배치되어 있더라도
- (**CPU가 바라보는 주소**인) ***<u>논리 주소 내에서</u>***는 <u>연속적</u>으로 배치해서, CPU 입장에서는 마치 연속적으로 배치된 것처럼 보이게 함

> 물리적으로는 분산되어 저장되어 있더라도, CPU 입장에서 본 <u>논리 주소는 연속적</u>으로 보임</br>
>
> ### CPU는 그저 논리 주소를 순차적으로 실행하면 될 뿐

</br></br>



#### 프로세스는 각기 다른 프로그램에 할당될 수 있기 때문에 페이지 테이블은 프로세스마다 있다.

</br></br></br>



## 내부 단편화

: 프로세스르 페이지로 쪼개는 과정에서, 똑같은 크기인 n으로 자르다가 n보다 작은 나머지 짜투리 페이지가 남을 수도 있음.</br></br>

그러면 페이지 크기보다 작은 짜투리도 어찌 됐건 메모리에 적재해야 하니까, 짜투리보다 큰 페이지 크기에 담아서 적재하면 그 페이지 안에는 짜투리와 ***나머지 빈 공간***이 발생</br>

</br>

즉, 하나의 페이지 크기보다 작은 공간은 낭비</br>

→ 내부 단편화

</br></br></br>



# PTBR

- 프로세스마다 페이지 테이블이 있다면, 각 ***페이지 테이블이 어디에 있는지 어떻게 알 수 있을까?***

→ CPU 안에 있는 `프로세스 테이블 베이스 레지스터`(PTBR)가 각 프로세스의 `페이지 테이블`이 메모리의 어디에 있는지 가리킴.</br>

> 만약, CPU가 프로세스 A를 실행하고 있다면</br>
>
> CPU 안에 있는 PTBR은 프로세스 A의 `페이지 테이블`이 어디에 저장되어 있는지를 가리키고 있음.

</br></br>

## 페이지 테이블이 메모리에 있으면 단점

- 페이지 테이블이 메모리에 있으면,
  - **페이지 테이블**을 참조하기 위해 한 번
  - **페이지**를 참조하기 위해 한 번

</br>

**메모리에 굳이 2번씩** 접근해야 해서, **메모리 접근 시간**이 **<u>2배</u>**가 됨</br>

#### → 그래서, 페이지 테이블이 메모리에 저장되어 있으면 안 좋다.

</br></br></br>



# TLB

페이지 테이블의 일부를 가져와서 저장하는 캐시 메모리 (현재 자주 참조하고 있는 페이지 테이블의 일부가 저장됨)</br>

→ 자주 참조하는 페이지/프레임 번호가 담긴 페이지 테이블을 TLB에 저장하고 있으니까, </br>

**페이지 테이블을 알기 위해 <u>메모리에 가는 빈도</u>**가 줄어듦</br>

</br></br>



- CPU가 접근하려는 논리 주소가 TLB에 있다면? ***TLB 히트***
  - **메모리 접근 한 번**만 해도 됨
- CPU가 접근하려는 논리 주소가 TLB에 없다면? ***TLB 미스***
  - **메모리 접근 2번** (페이지 테이블 참조하러 1번 & 프레임에 접근하기 위해서 1번)

</br></br></br>



# 페이징에서의 주소 변환

- <u>특정 주소에 접근</u>하려고 하면 **어떤 정보가 필요할까?**
  - **어떤 페이지/프레임**에 접근하고 싶은지
  - 접근하려는 주소가 그 **페이지 혹은 프레임으로부터 <u>얼마나 떨어져 있는지</u>**

</br>

이를 위해,</br>

페이징 시스템에서의 논리 주소는</br>

- 페이지 번호
- 변위 (offset) → 얼마나 떨어져 있는지

로 이루어져 있음</br>

</br></br>



즉, 페이징 시스템에서는</br>

- **<페이지 번호, 변위>**로 이루어진 **<u>논리 주소</u>**는
- 페이지 테이블을 통헤
- **<프레임 번호, 변위>**인 **<u>물리 주소</u>**로 변환된다.

> **Q.** **논리 주소에서의 변위** *(내가 접근하고자 하는 주소가 <u>페이지로부터</u> 얼마나 떨어져 있는지)*와 **물리 주소에서의 변위** *(내가 접근하고자 하는 주소가 <u>프레임으로부터</u> 얼마나 떨어져 있는지)*는 같을까?</br>
>
> → 같다. 페이지의 크기와 프레임의 크기는 같기 때문.</br>
>
> 크기가 같으니까, 내가 접근하려는 주소(정해짐)가 페이지로부터 얼마나, 프레임으로부터 얼마나 떨어져있는지는 같음

</br></br></br>

# 페이지 테이블 엔트리

**PTE**

페이지 테이블에는 `페이지 번호`, `프레임 번호` 말고도 **다른 정보들도 들어간다**. 이때 페이지 테이블에 들어가는 정보들은 `페이지 테이블 엔트리`에 **들어가 있다**고 한다.</br>

</br>

## 유효 비트

**현재 해당 페이지에 접근 가능한지** 여부를 알려주는 **비트**</br>

→ 현재 페이지가 **<u>스왑 영역으로 쫓겨나 있는지</u>**, 아니면 **<u>메모리에 적재되어 있는지</u>**를 나타냄.

</br></br>

- 유효 비트 1

  : 메모리에 적재되어 있는 페이지

</br>

- 유효 비트 0

  : 메모리에 적재 X 페이지 (보조기억장치의 스왑 영역에 있음)

> 유효 비트가 0인 페이지에 접근하려고 한다면?</br></br>
>
> → ***페이지 폴트***(page fault)라는 인터럽트 발생</br>
>
> (현재 접근하려고 하는 페이지가 메모리에 적재되어 있지 않을 때 발생하는 인터럽트)

</br></br></br>



## 보호 비트

**''페이지 보호 기능''**을 위해 존재하는 비트</br>

→ **읽기 전용 페이지**(**<u>쓰기 권한 없는</u>** 페이지)를 나타냄. (읽기만/쓰기만/실행만 으로 나눠서 보호비트가 있기도 함)

</br></br>

- 보호 비트 1

  : 읽기/쓰기/실행 영역 중에서 해당되는 권한만 가능할 때

</br>

- 보호 비트 0

  : 읽기/쓰기/실행 영역 중에서 해당되는 권한이 제한될 때

</br></br></br></br>



## 참조 비트

CPU가 이 페이지에 접근한 적이 있는지 여부</br>

→ 어떤 페이지가 메모리로 적재된 이후에 CPU가 한 번이라도 읽거나 쓴 페이지는 참조 비트가 1로 세팅됨

</br></br></br></br>



## 수정 비트

**dirty bit**</br>

CPU 이 페이지에 한 번이라도 데이터를 쓴 적이(write) 있는지 여부</br>

</br>

#### 수정 비트의 존재 이유?

이 페이지가 메모리로부터 없어질 때, 보조기억장치에 쓰기 작업을 해야 하는지 할 필요 없는지를 판단하기 위해서 존재</br>

</br>

예를 들어,</br>

**메모리**에 <u>페이지 A</u>가 있고, CPU가 메모리에 있는 페이지 A를 읽기만 하고 쓴 적이 없다면</br>

**보조기억장치**에 있는 페이지 A와 내용이 똑같을 것임.</br></br>



즉,</br>

CPU가 **메모리에 있는 <u>페이지 A</u>**의 **<u>내용을 변경</u>**했다면,</br>

페이지가 <u>스왑 아웃</u>될 때,</br>

**보조기억장치에 있는 <u>페이지 A</u>**에도 변경된 내용을 ***'쓰기 작업을 통해'*** 반영해야 함</br>

</br>

→ `수정 비트`를 통해 **판단**함</br>

</br>

> **수정 비트가 0**이라면 한 번도 변경된 적이 없으니까</br>
>
> 굳이 **<u>보조기억장치에 덮어쓰기 작업을 하지 않음.</u>**</br></br>
>
>  
>
> **수정 비트가 1**이라면 변경된 페이지의 내용을</br>
>
> **<u>보조기억장치에도 반영</u>**해야 한다.
