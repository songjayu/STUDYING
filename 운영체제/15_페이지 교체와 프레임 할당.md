# 들어가며

- 물리 메모리보다 큰 프로세스를 실행할 수 있지만
- 그럼에도 물리 메모리의 크기는 한정되어 있다

</br></br>

그렇기에, 운영체제 입장에서는

- 기존에 적재된 불필요한 페이지를 선별해 보조기억장치로 내보내고

  → ***페이지 교체 알고리즘***

</br>

- 프로세스들에게 적절한 수의 프레임을 할당해야 함

  *→ **프레임 할당***


</br></br>



# 요구 페이징

처음부터 모든 페이지를 적재하지 않고 필요한 페이지만을 메모리에 적재하는 기법

→ 요구되는 페이지만 적재하는 기법

</br>

> 1. CPU가 특정 페이지에 접근하는 명령어를 실행한다.
> 2. 해당 페이지가 현재 메모리에 있을 경우(유효 비트가 1) CPU는 페이지가 적재된 프레임에 접근한다.
> 3. 해당 페이지가 현재 메모리에 없을 경우(유효 비트가 0) 페이지 폴트가 발생한다.
> 4. 페이지 폴트 처리 루틴은 해당 페이지를 메모리로 적재하고 유효 비트를 1로 설정한다.
> 5. 다시 1번을 수행

</br>

## 요구 페이징이 해결해야 할 문제

: 페이지 교체, 프레임 할당</br>

</br></br></br>



# 페이지 교체 알고리즘

요구 페이징 기법으로 페이지들을 적재하다보면 언젠간 메모리가 가득 차게 된다

→ 당장 실행에 필요한 페이지를 적재하려면 **<u>적재된 페이지를 보조기억장치로</u>** 내보내야 함</br></br>

→ 이때, **어떤 페이지를 내보낼까?**</br></br>

→ 이걸 **결정하는 방법**(알고리즘)이 `페이지 교체 알고리즘`

</br></br>



## 무엇이 좋은 페이지 교체 알고리즘일까?

페이지 폴트가 적은 알고리즘!</br>

→ 페이지 폴트가 발생하면 보조기억자치에 접근해야 해서 성능 저하



