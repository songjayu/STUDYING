# 들어가며

- 연속 메모리 할당 : 프로세스에 연속적인 메모리 공간을 할당 (프로세스들이 메모리 내에서 연속적으로 할당되는 방식)

</br></br></br>



# 스와핑

- 지금 당장 사용되지 않는 프로세스들을 보조기억장치의 일부 영역(**스왑영역**)으로 쫓아내고
- 그렇게 생긴 빈 공간에 새 프로세스 적재

> 지금 사용 안하는 프로세스를 보조기억장치에 있는 ***스왑 영역으로 쫓아내는*** 작업 </br>
>
> → `스왑 아웃`</br>
>
> </br>
>
> 메모리에 빈 공간이 생겨서 스왑 영역에 있던 ***프로세스를 다시 메모리로*** 옮기는 작업</br>
>
> → `스왑 인`

</br>

## 장점

**프로세스들이 요구하는 메모리 공간 크기 > 실제 메모리 크기**</br>

일 때도 프로세스를 동시에 실행 가능함!</br></br></br>



# 연속 메모리 할당 방식의 종류

: `최초 적합`, `최적 적합`, `최악 적합`

→ 프로세스를 연속적으로 메모리 내에 배치할 때 어떤 빈 공간에 어떻게 적재할 지에 따라서 나눈 방식들</br>

</br>

## 최초 적합

**first-fit**</br>

: 운영체제가 메모리 내의 빈 공간을 순서대로 검색하다가 적재할 수 있는 공간을 발견하면, 그 공간에 프로세스를 배치하는 방식

</br></br>

### 장점

- 빈 공간을 검색하는 **시간이 최소화**, 그래서 **빠른 할당**

</br></br>



## 최적 적합

**best-fit**</br>

: 운영체제가 빈 공간을 모두 검색해본 뒤, 적재 가능한 가장 작은 공간에 할당

</br></br></br>



## 최악 적합

**worst-fit**</br>

: 운영체제가 빈 공간을 모두 검색해본 뒤, 적재 가능한 가장 큰 공간에 할당</br></br></br>



</br>

# 외부 단편화

- 사실 프로세스를 연속적으로 메모리에 할당하는 방식은 메모리를 효율적으로 사용하는 방법이 아님
- `외부 단편화`라는 문제가 발생하기 때문!

</br></br>

만약, 사용자 영역이 200MB일 때

- 크키가 50MB인 프로세스 A
- 30MB인 프로세스 B
- 100MB인 프로세스 C
- 20MB인 프로세스 D를 차례대로 적재해야 한다면?

→ ABCD 차례대로 메모리에 적재될 것임.

</br></br></br>



근데, 프로세스 B, D가 실행 끝나면?</br>

- 총 50MB의 빈 공간이 생김

### 하지만, C를 사이에 두고 30MB, 20MB로 분리된 채 빈 공간이 생기므로 50MB의 프로세스는 적재할 수 없음!

</br></br>

→ ***외부 단편화***</br>

: 프로세스들이 실행되고 종료되길 반복하면서 ***메모리 사이 사이에 빈 공간 발생***

</br>

즉,</br>

### 외부 단편화</br>

: 프로세스를 할당하기 어려울 만큼 작은 메모리 공간들로 인해 메모리가 낭비되는 현상</br>

(연속 메모리 할당 방식은 이런 외부 단편화 문제를 초래함)

</br></br></br></br>



# 외부 단편화 해결 방법

## 1. 메모리 압축(compaction)

→ ***메모리 조각 모음***이라고도 함</br>

여기저기 <u>흩어져 있는 빈 공간들을</u> **하나로 모으는 방식**</br>

프로세스를 적당히 재배치시켜 흩어져 있는 작은 빈 공간들을 하나의 큰 빈 공간으로 만드는 방법

</br></br>

### 부작용</br>

흩어져 있는 빈 공간을 하나로 합치는 과정에서, 실행 중인 프로세스를 재배치하는 과정에서</br>

***많은 오버헤드***를 일으키고, 프로세스들은 재배치되느라 ***제대로 실행되지 못 함*** </br>

</br>

그렇기 때문에,</br>

현대 운영체제에서 외부 단편화를 최소화하기 위해서 선택하는 <u>가장 대중적인 방식</u>은</br>

→ ***가상 메모리 기법, 페이징***

